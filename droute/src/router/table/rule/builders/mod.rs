// Copyright 2020 LEXUGE
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

mod ifblock;
// Please pub use every block builder here
pub use self::ifblock::IfBlockBuilder;

use super::{
    actions::{Action, Result as ActionResult},
    IfBlock, Result, SeqBlock,
};
use crate::{
    actions::ActionError,
    matchers::{MatchError, Matcher},
    router::table::TableError,
    AsyncTryInto, Label, Rule,
};
use async_trait::async_trait;
use serde::{
    de::{Deserializer, Error as _, SeqAccess, Visitor},
    Deserialize, Serialize,
};
use std::marker::PhantomData;

/// A parsed branch of a rule.
#[derive(Serialize, Clone)]
pub struct BranchBuilder<A: AsyncTryInto<Box<dyn Action>, Error = ActionError>> {
    seq: Vec<A>,
    next: Label,
}

// This customized deserialization process accept branches of this form:
// ```
// - Action1
// - Action2
// - ...
// - next
// ```
// Here the lifetime constraints are compatible with the ones from serde derivation. We are not adding them to `AggregatedActionBuilder` as they are gonna be automatically generated by serde.
impl<'de, A: AsyncTryInto<Box<dyn Action>, Error = ActionError> + Deserialize<'de>> Deserialize<'de>
    for BranchBuilder<A>
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum Either<A: AsyncTryInto<Box<dyn Action>, Error = ActionError>> {
            Action(A),
            Tag(Label),
        }

        struct BranchVisitor<A> {
            // Dummy variable for visitor to be constrained by `A`.
            t: PhantomData<A>,
        }

        impl<'de, A: AsyncTryInto<Box<dyn Action>, Error = ActionError> + Deserialize<'de>>
            Visitor<'de> for BranchVisitor<A>
        {
            type Value = BranchBuilder<A>;

            fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.write_str("a list of actions with the tag of the next rule as the last element")
            }

            fn visit_seq<V: SeqAccess<'de>>(
                self,
                mut sv: V,
            ) -> std::result::Result<Self::Value, V::Error> {
                let mut seq = Vec::new();

                // Get the `next` from the first element of the type Label.
                let next = loop {
                    match sv.next_element::<Either<A>>() {
                        Ok(Some(Either::Action(a))) => seq.push(a),
                        Ok(Some(Either::Tag(l))) => break l,
                        Ok(None) => {
                            return Err(V::Error::custom("Missing the tag of the next rule"))
                        }
                        Err(_) => {
                            return Err(V::Error::custom(
                                "Make sure elements in branch are either valid actions or label in the end. Failed to parse the branch",
                            ))
                        }
                    }
                };

                // Verify that this is indeed the last element.
                if sv.next_element::<Either<A>>()?.is_some() {
                    return Err(V::Error::custom(
                        "Extra element after the rule tag specified at last in the rule definition",
                    ));
                }

                Ok(Self::Value { seq, next })
            }
        }

        deserializer.deserialize_seq(BranchVisitor::<A> { t: PhantomData })
    }
}

impl<A: AsyncTryInto<Box<dyn Action>, Error = ActionError>> BranchBuilder<A> {
    /// Create a new BranchBuilder from a sequence of actions and the destination tag name.
    pub fn new(next: impl Into<Label>) -> Self {
        Self {
            seq: Vec::new(),
            next: next.into(),
        }
    }

    /// Create a branch builder from a list of action builders
    pub fn from_actions(seq: Vec<A>, next: impl Into<Label>) -> Self {
        Self {
            seq,
            next: next.into(),
        }
    }

    /// Add a single action builder to the list (in order)
    pub fn add_action(mut self, action: A) -> Self {
        self.seq.push(action);
        self
    }
}

#[async_trait]
impl<A: AsyncTryInto<Box<dyn Action>, Error = ActionError>>
    AsyncTryInto<(Vec<Box<dyn Action>>, Label)> for BranchBuilder<A>
{
    /// Build the ParMatchArm into the internal-used tuple by `Rule`.
    async fn async_try_into(self) -> ActionResult<(Vec<Box<dyn Action>>, Label)> {
        let mut built: Vec<Box<dyn Action>> = Vec::new();
        for a in self.seq {
            // TODO: Can we make this into a map?
            built.push(a.async_try_into().await?);
        }
        Ok((built, self.next))
    }

    type Error = ActionError;
}

impl<A: AsyncTryInto<Box<dyn Action>, Error = ActionError>> Default for BranchBuilder<A> {
    fn default() -> Self {
        Self {
            seq: vec![],
            next: "end".into(),
        }
    }
}

/// A builder for rule block
#[derive(Deserialize, Clone)]
#[serde(untagged)]
pub enum RuleBuilders<M, A>
where
    M: AsyncTryInto<Box<dyn Matcher>, Error = MatchError>,
    A: AsyncTryInto<Box<dyn Action>, Error = ActionError>,
{
    /// Sequence of actions
    SeqBlock(BranchBuilder<A>),

    /// If syntax rule
    IfBlock(IfBlockBuilder<M, A>),
}

#[async_trait]
impl<M, A> AsyncTryInto<Box<dyn Rule>> for RuleBuilders<M, A>
where
    for<'a> M: AsyncTryInto<Box<dyn Matcher>, Error = MatchError> + Deserialize<'a>,
    A: AsyncTryInto<Box<dyn Action>, Error = ActionError>,
{
    type Error = TableError;

    async fn async_try_into(self) -> Result<Box<dyn Rule>> {
        Ok(match self {
            Self::IfBlock(i) => Box::new(i.async_try_into().await?),
            Self::SeqBlock(s) => Box::new(SeqBlock::new(s.async_try_into().await?)),
        })
    }
}
